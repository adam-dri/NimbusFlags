# NimbusFlags/backend/services/sessions_service.py
"""Session management service for NimbusFlags.

Provides helpers to create, revoke, and look up short-lived dashboard
sessions stored in the PostgreSQL ``sessions`` table.
"""


from __future__ import annotations

import hashlib
import secrets
import uuid
from dataclasses import dataclass
from datetime import datetime, timedelta, timezone
from typing import Optional

try:
    # Case 1: imported as part of the `backend` package
    from ..repositories.db import get_connection  # type: ignore[import]
except ImportError:
    # Case 2: modules are used as top-level packages
    # (for example when running `python backend/app.py`)
    from repositories.db import get_connection  # type: ignore[import]


SESSION_TOKEN_PREFIX = "nsess_"
# Short TTL for now; you can increase to 7 days or more if needed.
SESSION_TTL_DAYS = 1


@dataclass(frozen=True)
class Session:
    """In-memory representation of a session row.

    Attributes:
        id: Unique identifier of the session (UUID).
        client_id: Identifier of the client (tenant) owning this session.
        created_at: Session creation timestamp (UTC).
        expires_at: Session expiration timestamp (UTC).
        revoked_at: Optional revocation timestamp (UTC) if the session
            has been explicitly revoked (e.g., logout).
    """

    id: uuid.UUID
    client_id: uuid.UUID
    created_at: datetime
    expires_at: datetime
    revoked_at: Optional[datetime] = None


def _generate_raw_token() -> str:
    """Generate a new raw session token.

    The token is:
        - Prefixed with ``SESSION_TOKEN_PREFIX`` (for example ``"nsess_"``).
        - Followed by a URL-safe, base64-like random string.

    Notes:
        ``secrets.token_urlsafe(32)`` generates 32 random bytes and
        encodes them using a URL-safe base64 alphabet. This yields a
        token that is:
            - High entropy (suitable for authentication),
            - Safe to put in URLs and HTTP headers.

    Returns:
        The raw session token string to be returned to the client.
    """
    # token_urlsafe returns a URL-safe, base64-like string.
    return SESSION_TOKEN_PREFIX + secrets.token_urlsafe(32)


def _hash_token(raw_token: str) -> str:
    """Compute the SHA-256 hash of a raw session token.

    The raw token is never stored in the database; only its hash is kept.
    This function centralizes the hashing strategy.

    Args:
        raw_token: The raw session token string as received from the
            client or generated by the backend.

    Returns:
        A hexadecimal SHA-256 digest of the token.
    """
    return hashlib.sha256(raw_token.encode("utf-8")).hexdigest()


def create_session_for_client(client_id: uuid.UUID) -> tuple[Session, str]:
    """Create a new session for the given client.

    This function:
        - Generates a new random session token.
        - Hashes the token and inserts a new row into the ``sessions`` table.
        - Builds an in-memory :class:`Session` object.
        - Returns both the Session object and the raw token.

    Args:
        client_id:
            UUID of the client (tenant) for which the session
            is created.

    Returns:
        A tuple ``(session, raw_token)`` where:
            - ``session`` is the in-memory :class:`Session` object
              (no raw token).
            - ``raw_token`` is the raw session token to return to the
              client.

    Notes:
        Only the hash of the token is stored in the database. The raw
        token must be returned to the frontend and stored securely
        (for example in an HTTP-only cookie on the dashboard domain).
    """
    session_id = uuid.uuid4()
    raw_token = _generate_raw_token()
    token_hash = _hash_token(raw_token)

    now = datetime.now(timezone.utc)
    expires_at = now + timedelta(days=SESSION_TTL_DAYS)

    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute(
                """
                INSERT INTO sessions (id, client_id, token_hash,
                                      created_at, expires_at)
                VALUES (%s, %s, %s, %s, %s)
                """,
                (str(session_id), str(client_id), token_hash, now, expires_at),
            )

    session = Session(
        id=session_id,
        client_id=client_id,
        created_at=now,
        expires_at=expires_at,
    )
    return session, raw_token


def delete_session_for_token(raw_token: str) -> None:
    """Delete (revoke) a session given its raw token.

    This is used by the logout endpoint. The function is idempotent:
    if the token does not exist, no error is raised.

    Args:
        raw_token:
            The raw session token string provided by the client.

    Returns:
        None. The session row is removed if it exists.
    """
    if not raw_token:
        return

    if not raw_token.startswith(SESSION_TOKEN_PREFIX):
        # Do not even hash obviously invalid tokens.
        return

    token_hash = _hash_token(raw_token)

    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute(
                "DELETE FROM sessions WHERE token_hash = %s",
                (token_hash,),
            )


def _row_to_session(row: dict) -> Session:
    """Map a database row to a :class:`Session` instance.

    Args:
        row: A row returned from the ``sessions`` table.

    Returns:
        A :class:`Session` object built from the row.
    """
    return Session(
        id=uuid.UUID(str(row["id"])),
        client_id=uuid.UUID(str(row["client_id"])),
        created_at=row["created_at"],
        expires_at=row["expires_at"],
        revoked_at=row.get("revoked_at"),
    )


def get_active_session_for_token(raw_token: str) -> Optional[Session]:
    """Resolve an *active* session for a given raw token.

    This is the low-level lookup used by higher-level authentication
    helpers (for example, a ``require_session`` decorator).

    A session is considered *active* if:
        - The token matches a row in the ``sessions`` table.
        - ``revoked_at`` is NULL (not explicitly revoked).
        - ``expires_at`` is strictly greater than the current UTC time.

    Args:
        raw_token:
            The raw session token string provided by the client.

    Returns:
        A :class:`Session` instance if a matching active session is
        found; otherwise ``None``.
    """
    if not raw_token:
        return None

    if not raw_token.startswith(SESSION_TOKEN_PREFIX):
        # Reject obviously invalid tokens early.
        return None

    token_hash = _hash_token(raw_token)
    now = datetime.now(timezone.utc)

    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute(
                """
                SELECT id,
                       client_id,
                       created_at,
                       expires_at,
                       revoked_at
                FROM sessions
                WHERE token_hash = %s
                  AND revoked_at IS NULL
                  AND expires_at > %s
                """,
                (token_hash, now),
            )
            row = cur.fetchone()

    if row is None:
        return None

    return _row_to_session(row)


def get_session_for_token(raw_token: str) -> Optional[Session]:
    """
    Backward-compatibile wrapper for legacy imports.

    Historically, other modules imported ``get_session_for_token`` from
    this module. The canonical implementation now lives in
    :func:`get_active_session_for_token`.

    Args:
        raw_token:
            The raw session token string provided by the client.

    Returns:
        A :class:`Session` instance if a matching active session is
        found; otherwise ``None``.
    """
    return get_active_session_for_token(raw_token)
